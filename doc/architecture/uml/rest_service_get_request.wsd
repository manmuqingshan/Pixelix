@startuml Get-Request
participant Plugin
participant RestService
participant AsyncHttpClient 
participant "RestService::m_responseQueue" as responseQ
participant TcpClient
entity Server

autoactivate on

-> RestService: start()
    RestService -> AsyncHttpClient: regOnResponse/Error/Closed
    RestService <-- AsyncHttpClient
<-- RestService

note over Plugin,Server
    Get-Request:
end note

Plugin <- : processTask runs
    Plugin -> RestService: get(URL, PreProcessCallback)
        RestService -> RestService: put request in m_requestQueue
        return
    Plugin <-- RestService: restId
Plugin -->

RestService <- : loopTask runs
    alt (RestCmd available) && (false == m_isWaitingForResponse)
        RestService -> RestService: m_isWaitingForResponse = true
        return

        RestService -> RestService: set m_activePreProcessCallback/m_activeRestId
        return 

        RestService -> AsyncHttpClient: begin(URL)
        RestService <-- AsyncHttpClient 

        RestService -> AsyncHttpClient: GET(restID)
            AsyncHttpClient -> AsyncHttpClient: put Cmd with restID in m_cmdQueue
            return
        RestService <-- AsyncHttpClient
    end
RestService -->

AsyncHttpClient <- : AsyncHttpClientTask runs
    alt cmd in m_cmdQueue available
        AsyncHttpClient -> AsyncHttpClient: takeGlobalMutex()
        return

        AsyncHttpClient -> AsyncHttpClient: getRequest()
            AsyncHttpClient -> AsyncHttpClient: connect()
                AsyncHttpClient -> TcpClient: connect()
                return
            return
        AsyncHttpClient <-- AsyncHttpClient
    end   
AsyncHttpClient -->

TcpClient <- : async_tcp(Task) runs
    TcpClient -> Server: send request
    TcpClient <-- Server
TcpClient -->

note over TcpClient, Server
    Asynchronous
end note

TcpClient <- : async_tcp(Task) runs
    loop for each TCP-chunk
        TcpClient <- Server: response
            TcpClient -> TcpClient: _sockIsReadable
                alt 0 < lwip_read()
                    TcpClient -> AsyncHttpClient:  _recv_cb()
                        AsyncHttpClient -> AsyncHttpClient: put evt with EVENT_ID_DATA in m_evtQueue
                        return
                    TcpClient <-- AsyncHttpClient

                else 0 == lwip_read()
                    TcpClient -> TcpClient: _close()
                        TcpClient -> AsyncHttpClient: _discard_cb()
                            AsyncHttpClient -> AsyncHttpClient: put evt with EVENT_ID_DISCONNECTED in m_evtQueue
                            return
                        TcpClient <-- AsyncHttpClient
                    return
                end
            return
        TcpClient --> Server
    end
TcpClient -->

AsyncHttpClient <- : AsyncHttpClientTask runs
    loop evt in m_evtQueue available
        alt EVENT_ID_DATA == evt.id
        AsyncHttpClient -> AsyncHttpClient: onData()
        alt event contains last part of response
                AsyncHttpClient -> AsyncHttpClient: notifyResponse()
                    AsyncHttpClient -> RestService: handleAsyncWebResponse(HttpResonse)
                        RestService -> Plugin: preProcessAsyncWebResponse()
                        RestService <-- Plugin

                        RestService -> responseQ: put response in m_responseQueue, response contains RestId
                        RestService <-- responseQ
                    AsyncHttpClient <-- RestService
                return
        end
        return
        else EVENT_ID_DISCONNECTED == evt.id
            AsyncHttpClient -> AsyncHttpClient: onDisconnect()
                AsyncHttpClient -> AsyncHttpClient: notifyClosed()
                    AsyncHttpClient -> RestService: onClosed-callback
                        RestService -> RestService: m_isWaitingForResponse = false
                        return
                    AsyncHttpClient <-- RestService
                return

                AsyncHttpClient -> AsyncHttpClient: giveGlobalMutex()
                return
            return
        end
    end
AsyncHttpClient -->

Plugin <- : processTask runs
    Plugin -> RestService: getResponse(restID)
        RestService -> responseQ: take response from m_responseQueue
        RestService <-- responseQ: response
    Plugin <-- RestService: isValidResponse, payload

    Plugin -> Plugin: react
    return
Plugin -->

@enduml